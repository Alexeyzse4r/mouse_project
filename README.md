# mouse_project

Техническое задание
Аннотация проекта
Разработка программного обеспечения для «превращения» смартфона на базе ОС Android в устройство ввода - компьютерную мышь.
Пронин Алексей Сергеевич –  тимлидер, алгоритмист.
Морозов Александр Евгеньевич –  разработчик ПК.
Филиппов Александр Сергеевич –  разработчик Android.
Капкаева Ангелина Олеговна – тестирование, анализ.
Ртищева Софья Александровна –  дизайнер, секретарь.


 
Введение
Актуальность в целом в мире и для вас лично – Мышка – удобный и, фактически, необходимый гаджет для работы большинства пользователей. Однако, носить ее с собой – дополнительная трудность. Мы, в свою очередь, также часто забываем взять мышку на занятия, что понижает качество работы с ПК. 
 
Особенности разработки
Технические особенности и реализация
Групповое взаимодействие, в основном, осуществлялось посредством личных встреч. Реже – Discord, Telegram. Далее каждый участник нашей команды опишет.	 Каждый участник проекта подготовил описание своей части работы.
Филиппов Александр Сергеевич – Android-разработчик. 
Цели: 
1) Разработка программной реализации интерфейса разработанного дизайнером
2) Функции передачи данных посредством проводного и беспроводного соединения смартфона и компьютера.
3) Подготовка кода для встраивания разработанного алгоритма обработки изображения
4) Компиляция APK
Реализовано:
1) Интерфейс приложения
2) Приложение готово к взаимодействию с другими частями проекта
  - Функция связи двух устройств посредством сокетов
  - Функция связи двух устройств по проводному соединению
3) Добавлен режим touchpad
4) Windows-приложение
Стек: Python3, Kivy, pyserial, buildozer, paytagui, plyer, socket
При создании приложения для смартфона мы использовали фреймворк кроссплатформенной разработки на Python3 под названием Kivy, так как Android Studio очень требовательна к мощности компьютера. Встроенные элементы Kivy позволили нам добавить режим Touchpad'а, который реализован через методы on_touch_down(), on_touch_up(), on_touch_move():
def on_touch_down(self, touch):
         print("Mouse Down", touch)
def on_touch_up(self, touch):
         print("Mouse Up", touch)
 def on_touch_move(self, touch):
        print("Mouse Move", touch)
 
Рисунок 1- возвращаемые координаты

По данным spos мы получаем координаты перемещения внутри окна приложения и отправляем их на компьютер. Приятный и легко реализуемый функционал, который изначально не был задуман, но благодаря выбранной нами библиотеки появился в нашем приложении. Полученные нами данные через режим touchpad’а или мышки мы отправляем на компьютер. Для реализации функций передачи данных мы подключали библиотеку pyserial и socket. При беспроводном подключении через сокеты:
def connection(ip):
    client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    client.connect((ip, 1234))
    while True:
        client.send(arr.encode("utf-8")) 
        print()

И при проводном соединении:
def send_port(self, x, y):
    arr = [2]
    arr[0] = x
    arr[1] = y
    ser = Serial(port='COM4', baudrate=115200, timeout=0.1)
    ser.open()
    self.write(ser, arr)
    if ser.is_open:
        ser.flushInput() #чистим буффер
        ser.flushOutput()
        try:
            ser.write(arr)
        except Exception as exc:
            print('type: {0}, message: {1}'.format(type(exc), str(exc)))


Каждый режим и главное меню приложения – это отдельных экран. Перемещение между экранами приложения реализовано через ScreenManager в Kivy. Каждый экран имеет свое имя и по нажатию кнопки “Menu”, происходит переход с заданной анимацией. Все это прописывалось в kv-вставке. Функционал же каждого экрана(режима) реализован по принципам ООП, где для каждого экрана создан отдельный класс и в нем прописаны методы для реализации описанных выше функций.
После проверки работоспособности всех элементов UI и структуры приложения я приступил к внешнему виду по дизайн-проекту, разработанному Софьей. Сложностью здесь стало то, что в Kivy есть два подхода к разметке и изменению размеров элементов на разных экранах. В целях сохранения масштабирования приложения для разных устройств я использовал метод, который рассчитывает размер и положение отдельного взятого элемента исходя из его процентного соотношения относительно экрана и layout'а, в котором он находится. Поэтому при описании UI позиция и размер приложения задаются через параметры size_hint и pos_hint. Из-за сложности вычисления размер подгонка и правильное размещение элементов заняло заметно больше времени, чем если бы мы делали приложение ориентируясь только на тестовое устройство. В процессе реализации дизайн-проекта я использовал Canvas. Это инструмент графического представления виджетов. Через встроенные в него инструкции мы реализовали закругление клавиш, установку фонового изображения, шаблоны текста и цвета для однотипных элементов UI, параметры их размеров и позиций (иногда приходилось перезаписывать их для каких-то клавиш или Label’ов). 
В процессе создания и тестирования приложения были написаны и опробованы различные вариации функций передачи данных, подключения акселерометра. Kv-файл был переписан несколько раз с нуля, менялась его конфигурация. Весь проект так же был несколько раз пересобран с использованием отдельного kv-файла или его вставки в “main” файл.


 
Морозов Александр Евгеньевич – разработчик приложения на ПК.
Цели: 
1) Сделать приложение для ПК.
2) Иметь подключение с телефоном.
3) Получать отправляемые значений.
Реализовано:
1) Визуальная составляющая с использованием pyqt5.
2) Подключение к телефону.
3) Получение значений через сокеты.
Стек: Python3, PyQt5 + QtDesigner, socket.
Передо мной стояла задача в создании приложения для компьютера. Начал я с поиска подходящей для меня библиотеки. Выбрал я библиотеку pyqt5, т.к. у неё есть так называемый конструктор и по ней много уроков в интернете. Первым делом были сделаны отдельные графические окна, т.е. макеты (Рисунок 1). Затем с помощью дизайна сделанного Соней Ртищевой, я наложил все текстуры (Рисунок 2).
 
Рисунок 1 – Макеты будущих окон
 
Рисунок 2 – Окна с наложенным дизайном
Далее было реализовано подключение между компьютером и телефоном с помощью сокетов. В консоль для наглядности выводится ip ПК. При подключении телефона к компьютеру выводится “Connect”, а ниже выводятся значения, отправленные с телефона. Всё это демонстрируется на Рисунке 3.
 
Рисунок 3 – Вывод в консоль
Также во время разработки я столкнулся с трудностями в невозможности одновременной работы графического приложения и приёма значений. Проблема была решена вынесением алгоритма в отдельный поток-функцию. 
Капкаева Ангелина Олеговна – аналитик, сбор и анализ данных социологического опроса.
Стек: Python3, GoogleColab, Яндекс-формы.
Цели:
1) Создание Яндекс-формы для проведения социологического исследования.
2) Сбор и анализ данных для выявления закономерностей и тенденций по возрастным признакам и личным предпочтениям.
3) Разработка программы для анализа полученных данных.
Реализовано:
1) Опрос с участием 215 человек разных возрастных и               профессиональных категорий.
2) Определены основные предпочтения пользователей.
3) Программно получены статистические данные и графики             используемых устройств и функций ноутбука и ПК.
Особенности разработки.
Если говорить о создании программы, на основе которого было проведено это исследование, то это было реализовано на языке Python помощью среды Google Colab. Для представления графиков в Python есть одна из самых популярных библиотек Matplotlib. Для визуализации данных используются 4 части графика: фигуры (figure), координатной плоскости (axes), осей (axis), данные на графике (artist).
Пример кода для графика зависимости выбора ПК или ноутбука от возраста:

import matplotlib.pyplot as plt
import csv
x = []
y = []
with open('/content/Опрос.csv','r') as csvfile:
       lines = csv.reader(csvfile, delimiter=',')
       for row in lines:
              x.append(row[0])
              y.append(row[9])
plt.plot(y, color = 'g', linestyle = '-', marker = 'o')  
plt.xticks(rotation = 25)
plt.xlabel('Возраст')
plt.ylabel('Ответ')
plt.title('Использование ноутбука или ПК в зависимости от возраста', fontsize = 28)
plt.xlim([0, 71])
plt.ylim([0.5, 2.5])
plt.grid()
plt.legend()
plt.show()

Matplotlib.pyplot это набор функций, где пакет pyplot содержит большинство функций для создания фигуры, области её построения и проведения линий в этой области.
 
Рисунок 1 – Пример диаграммы зависимости выбора устройства от возраста
Ртищева Софья Александровна – разработчик дизайна.
Цели:
1)	Разработка дизайна интерфейсов для приложений на ПК и Android
Реализовано:
1) Прототипы интерфейсов
2) Интерфейс приложения для ПК с помощью растровой и векторной графики
3) Интерфейс приложения для Android с помощью        программного кода
4) Визуальное сопровождение проекта 
Для приложения разработана тёмная тема, так как оно будет использоваться на смартфоне, повёрнутом экраном вверх. Если сделать приложение в светлых оттенках, то при перемещении телефона пользователь будет периферическим зрением замечать движение яркого объекта, что снижает концентрацию и внимание. Использован ярко-зелёный цвет. Оттенки зелёного нейтральны в социальном восприятия, о них нет общепринятых стереотипов, а также уже на протяжении как минимум 2 сезонов являются одними из самых популярных цветов.
Для текста использована гарнитура Montserrat. Этот шрифт бесплатен для личного и коммерческого использования, что облегчает его применение с правовой точки зрения. Это геометрический гротеск с открытым характером. Шрифт легко читается и различается. Он часто встречается в диджитал дизайне - это один из самых популярных гротесков, его некоторая банальность делает его очень узнаваемым и понятным.
Мобильное приложение оптимизировано под положение руки, так как оно должно симулировать компьютерную мышь.
Фирменные элементы - четырёхконечная звёздочка и курсор. Это работа с ассоциациями (первичными и вторичными). Курсор - это ассоциация с мышью, звёздочка - клик. Буквально "наведи и кликни".
       

Пронин Алексей Сергеевич– тимлидер, разработчик алгоритма.
Цели: 
1)Реализовать алгоритм обработки изображений. Основное качественное требование - работа с видео, снятого в плоскости передвижения телефона по столу.
2)Реализовать дополнительные алгоритмы, решающие поставленную задачу, качественные требования которых не ограничены. 
Реализовано:
1) Трекеры:
KCF
CSRT
2) Одометрия:
ORB-дескрипторы
Сшивание изображений (панорамизация) 
3) Face:
Face Recognition
Facial landmarks, features
Стек: Python3, cv2, PyQt5 + QtDesigner, socket.
Я занимался алгоритмами обработки изображений и, конечно же, это тесно связано с библиотекой openCV.
Первым делом я подумал про одометрию с ключевыми точками. Есть два достаточно популярных алгоритма одометрии (фактически - расстановки дескрипторов) : SIFT и SURF. Однако они запатентованы и запрещены к комерческому использованию, ORB(Детектор ключевых точек FAST, дескрипторы BRIEF) в свою очередь эффективная альтернатива. В последствии, я попробовал применить алгоритм панорамизации для создания карты, но проблемы были те же. 
		
		import cv2
orb = cv2.ORB_create()
kp = orb.detect(img,None)
kp, des = orb.compute(img, kp)
Простейшая реализация расстановки точек, с которыми в последствии работаем.
import cv2
import numpy as np

img1 = cv2.imread("5.jpg")
img2 = cv2.imread("6.jpg")

img1_gray = cv2.cvtColor(img1, cv2.COLOR_BGR2GRAY)
img2_gray = cv2.cvtColor(img2, cv2.COLOR_BGR2GRAY)

orb = cv2.ORB_create(nfeatures=2000)

keypoints1, descriptors1 = orb.detectAndCompute(img1, None)
keypoints2, descriptors2 = orb.detectAndCompute(img2, None)


print(descriptors1, 'DSDDSDDSSD\n', descriptors2)

bf = cv2.BFMatcher_create(cv2.NORM_HAMMING)

matches = bf.knnMatch(descriptors1, descriptors2,k=2)


def draw_matches(img1, keypoints1, img2, keypoints2, matches):
    r, c = img1.shape[:2]
    r1, c1 = img2.shape[:2]

    output_img = np.zeros((max([r, r1]), c + c1, 3), dtype='uint8')
    output_img[:r, :c, :] = np.dstack([img1, img1, img1])
    output_img[:r1, c:c + c1, :] = np.dstack([img2, img2, img2])

    for match in matches:
        img1_idx = match.queryIdx
        img2_idx = match.trainIdx
        (x1, y1) = keypoints1[img1_idx].pt
        (x2, y2) = keypoints2[img2_idx].pt

        cv2.circle(output_img, (int(x1), int(y1)), 4, (0, 255, 255), 1)
        cv2.circle(output_img, (int(x2) + c, int(y2)), 4, (0, 255, 255), 1)
        cv2.line(output_img, (int(x1), int(y1)), (int(x2) + c, int(y2)), (0, 255, 255), 1)

    return output_img

all_matches = []
for m, n in matches:
  all_matches.append(m)

img3 = draw_matches(img1_gray, keypoints1, img2_gray, keypoints2, all_matches[:30])
cv2.imwrite('ds.jpg', img3)

good = []
for m, n in matches:
    if m.distance < 0.6 * n.distance:
        good.append(m)


def warpImages(img1, img2, H):
    rows1, cols1 = img1.shape[:2]
    rows2, cols2 = img2.shape[:2]

    list_of_points_1 = np.float32([[0, 0], [0, rows1], [cols1, rows1], [cols1, 0]]).reshape(-1, 1, 2)
    temp_points = np.float32([[0, 0], [0, rows2], [cols2, rows2], [cols2, 0]]).reshape(-1, 1, 2)
    list_of_points_2 = cv2.perspectiveTransform(temp_points, H)
    list_of_points = np.concatenate((list_of_points_1, list_of_points_2), axis=0)
    [x_min, y_min] = np.int32(list_of_points.min(axis=0).ravel() - 0.5)
    [x_max, y_max] = np.int32(list_of_points.max(axis=0).ravel() + 0.5)
    translation_dist = [-x_min, -y_min]
    H_translation = np.array([[1, 0, translation_dist[0]], [0, 1, translation_dist[1]], [0, 0, 1]])
    output_img = cv2.warpPerspective(img2, H_translation.dot(H), (x_max - x_min, y_max - y_min))
    output_img[translation_dist[1]:rows1 + translation_dist[1], translation_dist[0]:cols1 + translation_dist[0]] = img1
    return output_img

MIN_MATCH_COUNT = 10

if len(good) > MIN_MATCH_COUNT:
    src_pts = np.float32([keypoints1[m.queryIdx].pt for m in good]).reshape(-1, 1, 2)
    dst_pts = np.float32([keypoints2[m.trainIdx].pt for m in good]).reshape(-1, 1, 2)
    M, _ = cv2.findHomography(src_pts, dst_pts, cv2.RANSAC, 5.0)
    result = warpImages(img2, img1, M)
    cv2.imwrite('res.jpg', result)
    print("ALLL")
Реализация панорамизации двух изображений с использованием ORB-трекера без коэффициентов искажения изображения.

Было реализовано несколько алгоритмов трекинга, наиболее успешные из которых представлены на слайде. KCF расшифрован как кернелизированный корреляционный фильтр, работает на основе каскада HAAR с дополнительной обвязкой. Он быстрее, но менее точный. CSRT - фильтр дискриминативной корреляции с каналом и пространственной надежности. Медленнее(25кадров/с) и надежнее. Математику затрагивать не будем, но информация для интересующихся есть.
tracker_1 = cv2.TrackerKCF_create()
tracker_2 = cv2.TrackerKCF_create()
frame = cv2.imread(os.path.join('tis','1.jpg'))
#ok,frame=video.read()
height, width, _ = frame.shape
bbox_1 = (int(width*0.25), 0, int(width*0.15), int(height))
bbox_2 = (int(width*0.75), 0, int(width*0.15), int(height))
#bbox_1 = cv2.selectROI(frame)
#bbox_2 = cv2.selectROI(frame)
ok = tracker_1.init(frame,bbox_1)
ok = tracker_2.init(frame,bbox_2)
images = []
for filename in os.listdir('tis'):
    frame = cv2.imread(os.path.join('tis',filename))
    if frame is not None:
        #ok, frame = video.read()
        #if not ok:
        ok, bbox_1 = tracker_1.update(frame)
        ok, bbox_2 = tracker_2.update(frame)
        if ok:
            (x, y, w, h) = [int(v) for v in bbox_1]
            cv2.rectangle(frame, (x, y), (x + w, y + h), (0, 255, 0), 2, 1)
            (x, y, w, h) = [int(v) for v in bbox_2]
            cv2.rectangle(frame, (x, y), (x + w, y + h), (0, 255, 0), 2, 1)
        else:
            cv2.putText(frame, 'Error', (100, 0), cv2.FONT_HERSHEY_SIMPLEX, 1, (0, 0, 255), 2)
        cv2.imshow('Tracking', frame)
        if cv2.waitKey(1) & 0XFF == 27:
            break
cv2.destroyAllWindows()
Реализация двух параллельно работающих KCF-трекеров.
Так же был применен алгоритм распознавания лица, в котром, к слову, тоже используется каскад HAAR.
 
Внешний вид и взаимодействие с пользователем (руководство пользователя)
Руководства пользователя
На главном экране вы видите три клавиши, две из них переводят вас на экраны работы в режиме мышки или touchpad’а. При проводном подключении никаких дополнительных действий для работы не требуется, мы просто подключаете провод в ваш смартфон и компьютер. 
В случае беспроводного соединения:
1. Открыть командную строку вашего компьютера, что вы можете сделать через поиск одноименного приложения на вашем ПК или ввести в поиске “cmd”. 
 
2. Далее введите команду ipconfig и нажмите Enter. Далее введите команду “ipconfig” и нажмите Enter. В разделе “Адаптер беспроводной локальной сети Беспроводная сеть:” вы сможете увидеть параметр IPv4-адрес – это и есть ip вашего компьютера.
 
3. Вводите значение этого поля в приложении и нажимаете Enter. 
 
После это ваше приложение готово к работе и можете переходить в нужный вам режим и начинать использовать ваш телефон, как мышку. 




Проблемы в реализации проекта
Филиппов Александр Сергеевич – Android-разработчик:
В процессе создания и тестирования приложения были написаны и опробованы различные вариации функций передачи данных и подключения акселерометра. Kv-файл был переписан несколько раз с нуля, менялась его конфигурация. Весь проект так же был несколько раз пересобран с использованием отдельного kv-файла или его вставки в “main” файл. 
Был изменен подход к размещению элементов с целью возможности масштабирования приложения, о чем я писал выше.
Первой сложностью стало то, что в Kivy есть два подхода к разметке и изменению размеров элементов на разных экранах. В целях сохранения масштабирования приложения для разных устройств я использовал метод, который рассчитывает размер и положение отдельного взятого элемента исходя из его процентного соотношения относительно экрана и layout'а, в котором он находится. Поэтому при описании UI позиция и размер приложения задаются через параметры size_hint и pos_hint. Из-за сложности вычисления размер подгонка и правильное размещение элементов заняло заметно больше времени, чем если бы мы делали приложение ориентируясь только на тестовое устройство.
Помимо этого, в процессе попыток компиляции APK-файла, приложение изменялось с целью избавится от ошибок выдаваемых buildozer’ом. С целью решить это приложение было переписано с двух файлов (main.py и kv-файла) в единый main файл с kv-вставкой. Так как этот переход требовал некоторых изменений, процесс решения всех возникающих ошибок занял время. По причине отсутствия некоторых параметров в описании Label’ов или кнопок. Переход между экранами ранее реализованый в kv-файле оказался нерабочим в случае перехода на kv-вставку. Эту проблему удалось решить с помощью ScreenManager. Так же идея о kv-вставке не сразу пришла к нам в голову(отдельное спасибо Морозову Александру, который предположил, что так можно сделать), и приложение переписывалось полностью на Python3, без использования преимуществ выбранного нами фреймворка. Но подобный подход в случае с наличием 2 и более layout’ов, где один находится внутри другого, совершенно неудобен, по причине организации этого в коде. Так как реализуется это через метод inside, то уже к моменту описания всего лишь второго layout’a внутри другого, ваш код начинает выглядеть так:
      super(MainWindow, self).__init__(**kwargs)
        self.cols = 1
        self.rows = 5

        self.add_widget(Label(color=(0, 0, 0, 1), bold=True, italic=True, pos_hint={'center_x': 0.5}, size=(270, 50)))
        self.inside = GridLayout()
        self.inside.cols = 1
        self.inside.spacing = 10
        self.inside.padding = 30, 60, 10, 30
        self.inside.inside = GridLayout()
        self.inside.inside.cols = 2
        self.inside.inside.size_hint_x = self.parent * 0.04
        self.inside.inside.size_hint_y = self.parent.height * 0.0004
        self.inside.inside.add_widget(Label(text="IP: ",

Что совершенно путает в процессе разработки. В этом случае, например, код реализации главного окна приложения будет выглядеть как:
self.inside.inside.inside.inside.параметр.
В таком случае даже не расставляется табуляция и все описание всех layout’ов окна превращается в сплошной текст.
Морозов Александр Евгеньевич– разработчик приложения на ПК:
Во время связки окон между собой, я столкнулся с трудностями, т.к. выяснил, что pyqt5 больше используется для создания однооконных приложений. Позже я решил эту проблему, написав алгоритм, связывающий следующее окно с предыдущим.
Также была проблема в невозможности одновременной работы графического приложения и приёма значений. Проблема была решена вынесением алгоритма в отдельный поток-функцию.
Капкаева Ангелина Олеговна – аналитик, сбор и анализ данных социологического опроса.
Данные опроса записывались в cvs-файл. Поэтому было непривычно работать с таким форматом таблицы. Вопросы и ответы записывались не в удобном формате для анализа данных, поэтому приходилось изменять данные вручную.
Ртищева Софья Александровна – разработчик дизайна.
В ходе выполнения проекта, а именно разработки дизайна для мобильного приложения, стало понятно, что внедрение дизайна с помощью растровой графики, как это было сделано для ПК-приложения, невозможно ввиду особенностей работы фреймворка kivy с объектами растровой графики. Проблема была решена внедрением объектов дизайна с помощью программного кода.
Пронин Алексей Сергеевич– тимлидер, разработчик алгоритма.
	Проблема, относящаяся ко всем алгоритмам – слишком большое и изменчивое расстояние до определяемого объекта(небо, потолок и тд), что влечет за собой маленькую чувствительность алгоритма.
	Резюмируя, ошибка в подходе к проекту заключается в применении частично неподходящего стэка разработки, а также выборе слишком сложного и объемного проекта конкретно для данных условий разработки.


 
Заключение
Как промежуточный итог, мы имеем три готовых модуля: приложение на ПК, приложение на Android (связанное с приложением ПК), пул реализованных алгоритмов обработки изображения. Участниками команды был изучены следующий стек инструментов: фреймворки для кроссплатформенной разработки: kivy, PyQt5, кроссплатформенная свободная среда для разработки графических интерфейсов Qt Designer, среда разработки google colab, библиотека для расчетов математической статистики numpy+matplotlib, онлайн-редактор figma и редактор изображений photoshop, алгоритмы: корреляционного сравнения изображений,   нахождения ключевых точек, расстановки и анализа дескрипторов, паноромизации, каскады HAAR, распознавание ключевых точек на лице, openCV.
 	Как уже написано выше, ошибка в подходе к проекту заключается в применении частично неподходящего стэка разработки, а также выборе слишком сложного и объемного проекта конкретно для данных условий разработки. Мы бы посоветовали себе не использовать сторонние решения на других языках, а применять целевые платформы разработки. Пример тому kivy и Android Studio. В своей работе, мы в который раз подтвердили расхожее выражение: “Нет ничего более постоянного, чем временное”. Стоит меньше времени уделять прототипам, больше акцентировать свое внимание на конечном продукте.
	Нашей команде очень понравилась задача разработки проектов. Однако, мы бы посоветовали сделать больший приоритет, например, в баллах, работе над проектом для повышения вовлеченности студентов в работу. 
